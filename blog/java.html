<!DOCTYPE html>
<html lang="en-us">
  
  <head>
    <meta charset="UTF-8">
    <title>Java Blog</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="https://material.angularjs.org/1.1.1/docs.css" rel='stylesheet' type='text/css' ></link>
    <link rel="stylesheet" type="text/css" href="/stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheets/github-light.css" media="screen">
	<link rel="stylesheet" type="text/css" href="/stylesheets/custom.css" media="screen">
    
  </head>

<body>

<div style="padding-left: 2%; padding-right: 2%;">

<h1 align="center" > Java Notes </h1>	

<h5 align="left"  > published on 10 Oct. 2010 </h5>

<hr>

</br>



<pre>

<a name="JavaForkandJoinusingForkJoinPool" href="#JavaForkandJoinusingForkJoinPool" >Java Fork and Join using ForkJoinPool</a>

				
The ForkJoinPool was added to Java in Java 7. The ForkJoinPool is similar to the Java ExecutorService but with one difference. The ForkJoinPool makes it easy for tasks to split their work up into smaller tasks which are then submitted to the ForkJoinPool too. Tasks can keep splitting their work into smaller subtasks for as long as it makes to split up the task. It may sound a bit abstract, so in this fork and join tutorial I will explain how the ForkJoinPool works, and how splitting tasks up work. 

<b>Fork and Join Explained</b>

Before we look at the ForkJoinPool I want to explain how the fork and join principle works in general.

The fork and join principle consists of two steps which are performed recursively. These two steps are the fork step and the join step.

<b>Fork</b>

A task that uses the fork and join principle can fork (split) itself into smaller subtasks which can be executed concurrently. This is illustrated in the diagram below: 

<img src="/templates/programming/java/java-fork-and-join-1.png" />

By splitting itself up into subtasks, each subtask can be executed in parallel by different CPUs, or different threads on the same CPU.

A task only splits itself up into subtasks if the work the task was given is large enough for this to make sense. There is an overhead to splitting up a task into subtasks, so for small amounts of work this overhead may be greater than the speedup achieved by executing subtasks concurrently.

The limit for when it makes sense to fork a task into subtasks is also called a threshold. It is up to each task to decide on a sensible threshold. It depends very much on the kind of work being done.


<b>Join</b>

When a task has split itself up into subtasks, the task waits until the subtasks have finished executing.

Once the subtasks have finished executing, the task may join (merge) all the results into one result. This is illustrated in the diagram below: 

<img src="/templates/programming/java/java-fork-and-join-2.png" />

Of course, not all types of tasks may return a result. If the tasks do not return a result then a task just waits for its subtasks to complete. No result merging takes place then.

<b>The ForkJoinPool</b>

The ForkJoinPool is a special thread pool which is designed to work well with fork-and-join task splitting. The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool.

<b>Creating a ForkJoinPool</b>

You create a ForkJoinPool using its constructor. As a parameter to the ForkJoinPool constructor you pass the indicated level of parallelism you desire. The parallelism level indicates how many threads or CPUs you want to work concurrently on on tasks passed to the ForkJoinPool. Here is a ForkJoinPool creation example: 
    
    ForkJoinPool forkJoinPool = new ForkJoinPool(4);
    
This example creates a ForkJoinPool with a parallelism level of 4. 

<b>Submitting Tasks to the ForkJoinPool</b>

You submit tasks to a ForkJoinPool similarly to how you submit tasks to an ExecutorService. You can submit two types of tasks. A task that does not return any result (an "action"), and a task which does return a result (a "task"). These two types of tasks are represented by the RecursiveAction and RecursiveTask classes. How to use both of these tasks and how to submit them will be covered in the following sections. 

<b>RecursiveAction</b>

A RecursiveAction is a task which does not return any value. It just does some work, e.g. writing data to disk, and then exits.

A RecursiveAction may still need to break up its work into smaller chunks which can be executed by independent threads or CPUs.

You implement a RecursiveAction by subclassing it. Here is a RecursiveAction example: 

<div class="code_container">
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.RecursiveAction;

public class MyRecursiveAction extends RecursiveAction {

    private long workLoad = 0;

    public MyRecursiveAction(long workLoad) {
        this.workLoad = workLoad;
    }

    @Override
    protected void compute() {

        //if work is above threshold, break tasks up into smaller tasks
        if(this.workLoad > 16) {
            System.out.println("Splitting workLoad : " + this.workLoad);

            List<MyRecursiveAction> subtasks =
                new ArrayList<MyRecursiveAction>();

            subtasks.addAll(createSubtasks());

            for(RecursiveAction subtask : subtasks){
                subtask.fork();
            }

        } else {
            System.out.println("Doing workLoad myself: " + this.workLoad);
        }
    }

    private List<MyRecursiveAction> createSubtasks() {
        List<MyRecursiveAction> subtasks =
            new ArrayList<MyRecursiveAction>();

        MyRecursiveAction subtask1 = new MyRecursiveAction(this.workLoad / 2);
        MyRecursiveAction subtask2 = new MyRecursiveAction(this.workLoad / 2);

        subtasks.add(subtask1);
        subtasks.add(subtask2);

        return subtasks;
    }

}


import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.RecursiveAction;

public class MyRecursiveAction extends RecursiveAction {

    private long workLoad = 0;

    public MyRecursiveAction(long workLoad) {
        this.workLoad = workLoad;
    }

    @Override
    protected void compute() {

        //if work is above threshold, break tasks up into smaller tasks
        if(this.workLoad > 16) {
            System.out.println("Splitting workLoad : " + this.workLoad);

            List<MyRecursiveAction> subtasks =
                new ArrayList<MyRecursiveAction>();

            subtasks.addAll(createSubtasks());

            for(RecursiveAction subtask : subtasks){
                subtask.fork();
            }

        } else {
            System.out.println("Doing workLoad myself: " + this.workLoad);
        }
    }

    private List<MyRecursiveAction> createSubtasks() {
        List<MyRecursiveAction> subtasks =
            new ArrayList<MyRecursiveAction>();

        MyRecursiveAction subtask1 = new MyRecursiveAction(this.workLoad / 2);
        MyRecursiveAction subtask2 = new MyRecursiveAction(this.workLoad / 2);

        subtasks.add(subtask1);
        subtasks.add(subtask2);

        return subtasks;
    }

}

</div>



This example is very simplified. The MyRecursiveAction simply takes a fictive workLoad as parameter to its constructor. If the workLoad is above a certain threshold, the work is split into subtasks which are also scheduled for execution (via the .fork() method of the subtasks. If the workLoad is below a certain threshold then the work is carried out by the MyRecursiveAction itself.

You can schedule a MyRecursiveAction for execution like this: 

    MyRecursiveAction myRecursiveAction = new MyRecursiveAction(24);

    forkJoinPool.invoke(myRecursiveAction);
    

<b>RecursiveTask</b>

A RecursiveTask is a task that returns a result. It may split its work up into smaller tasks, and merge the result of these smaller tasks into a collective result. The splitting and merging may take place on several levels. Here is a RecursiveTask example: 

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.RecursiveTask;
    
    
public class MyRecursiveTask extends RecursiveTask<Long> {

    private long workLoad = 0;

    public MyRecursiveTask(long workLoad) {
        this.workLoad = workLoad;
    }

    protected Long compute() {

        //if work is above threshold, break tasks up into smaller tasks
        if(this.workLoad > 16) {
            System.out.println("Splitting workLoad : " + this.workLoad);

            List<MyRecursiveTask> subtasks =
                new ArrayList<MyRecursiveTask>();
            subtasks.addAll(createSubtasks());

            for(MyRecursiveTask subtask : subtasks){
                subtask.fork();
            }

            long result = 0;
            for(MyRecursiveTask subtask : subtasks) {
                result += subtask.join();
            }
            return result;

        } else {
            System.out.println("Doing workLoad myself: " + this.workLoad);
            return workLoad * 3;
        }
    }

    private List<MyRecursiveTask> createSubtasks() {
        List<MyRecursiveTask> subtasks =
        new ArrayList<MyRecursiveTask>();

        MyRecursiveTask subtask1 = new MyRecursiveTask(this.workLoad / 2);
        MyRecursiveTask subtask2 = new MyRecursiveTask(this.workLoad / 2);

        subtasks.add(subtask1);
        subtasks.add(subtask2);

        return subtasks;
    }
}

This example is similar to the RecursiveAction example except it returns a result. The class MyRecursiveTask extends RecursiveTask<Long> which means that the result returned from the task is a Long .

The MyRecursiveTask example also breaks the work down into subtasks, and schedules these subtasks for execution using their fork() method.

Additionally, this example then receives the result returned by each subtask by calling the join() method of each subtask. The subtask results are merged into a bigger result which is then returned. This kind of joining / mergining of subtask results may occur recursively for several levels of recursion.

You can schedule a RecursiveTask like this: 

    MyRecursiveTask myRecursiveTask = new MyRecursiveTask(128);

    long mergedResult = forkJoinPool.invoke(myRecursiveTask);

    System.out.println("mergedResult = " + mergedResult); 
    
Notice how you get the final result out from the ForkJoinPool.invoke() method call.

<b>ForkJoinPool Critique</b>

It seems not everyone is equally happy with the new ForkJoinPool in Java 7. While searching for experiences with, and opinions about, the ForkJoinPool, there are some critique: 

    <a href='http://coopsoft.com/ar/CalamityArticle.html'> A Java Fork-Join Calamity </a>

It is well worth a read before you plan to use the ForkJoinPool in your own projects. 

<hr style="border-top: 1px;" />

</pre>



<pre> 

<a name="Java8NewFeatures" href="#Java8NewFeatures" >Java 8 New Features</a>


New Features
There are dozens of features added to Java 8, the most significant ones are mentioned below −

    Lambda expression − Adds functional processing capability to Java.
    Method references − Referencing functions by their names instead of invoking them directly. Using functions as parameter.
    Default method − Interface to have default method implementation.
    New tools − New compiler tools and utilities are added like ‘jdeps’ to figure out dependencies.
    Stream API − New stream API to facilitate pipeline processing.
    Date Time API − Improved date time API.
    Optional − Emphasis on best practices to handle null values properly.
    Nashorn, JavaScript Engine − A Java-based engine to execute JavaScript code.

Along with these new featuers, lots of feature enhancements are done under-the-hood, at both compiler and JVM level.

- sample for java 8

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

public class Java8Tester {
   public static void main(String args[]){
   
      List<String> names1 = new ArrayList<String>();
      names1.add("Mahesh ");
      names1.add("Suresh ");
      names1.add("Ramesh ");
      names1.add("Naresh ");
      names1.add("Kalpesh ");
  
      List<String> names2 = new ArrayList<String>();
      names2.add("Mahesh ");
      names2.add("Suresh ");
      names2.add("Ramesh ");
      names2.add("Naresh ");
      names2.add("Kalpesh ");
  
      Java8Tester tester = new Java8Tester();
      System.out.println("Sort using Java 7 syntax: ");
  
      tester.sortUsingJava7(names1);
      System.out.println(names1);
      System.out.println("Sort using Java 8 syntax: ");
  
      tester.sortUsingJava8(names2);
      System.out.println(names2);
   }
   
   //sort using java 7
   private void sortUsingJava7(List<String> names){   
      Collections.sort(names, new Comparator<String>() {
         @Override
         public int compare(String s1, String s2) {
            return s1.compareTo(s2);
         }
      });
   }
   
   //sort using java 8
   private void sortUsingJava8(List<String> names){
      Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
   }
}




Lambda expression facilitates functional programming, and simplifies the development a lot.


A lambda expression is characterized by the following syntax −

parameter -> expression body

Following are the important characteristics of a lambda expression −

    Optional type declaration − No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.
    Optional parenthesis around parameter − No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.
    Optional curly braces − No need to use curly braces in expression body if the body contains a single statement.

Optional return keyword − The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.



public class Java8Tester {
   public static void main(String args[]){
      Java8Tester tester = new Java8Tester();
  
      //with type declaration
      MathOperation addition = (int a, int b) -> a + b;
  
      //with out type declaration
      MathOperation subtraction = (a, b) -> a - b;
  
      //with return statement along with curly braces
      MathOperation multiplication = (int a, int b) -> { return a * b; };
  
      //without return statement and without curly braces
      MathOperation division = (int a, int b) -> a / b;
  
      System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
      System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
      System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
      System.out.println("10 / 5 = " + tester.operate(10, 5, division));
  
      //with parenthesis
      GreetingService greetService1 = message ->
      System.out.println("Hello " + message);
  
      //without parenthesis
      GreetingService greetService2 = (message) ->
      System.out.println("Hello " + message);
  
      greetService1.sayMessage("Mahesh");
      greetService2.sayMessage("Suresh");
   }
 
   interface MathOperation {
      int operation(int a, int b);
   }
 
   interface GreetingService {
      void sayMessage(String message);
   }
 
   private int operate(int a, int b, MathOperation mathOperation){
      return mathOperation.operation(a, b);
   }
}


Lambda expressions are used primarily to define inline implementation of a functional interface, i.e., an interface with a single method only. In the above example, we've used various types of lambda expressions to define the operation method of MathOperation interface. Then we have defined the implementation of sayMessage of GreetingService.

Lambda expression eliminates the need of anonymous class and gives a very simple yet powerful functional programming capability to Java.

Method references help to point to methods by their names. A method reference is described using :: (double colon) symbol. A method reference can be used to point the following types of methods −

    Static methods
    Instance methods
    Constructors using new operator (TreeSet::new)

	

Method Reference Example

Let's look into an example of method referencing to get a more clear picture. Write the following program in an code editor and match the results.

import java.util.List;
import java.util.ArrayList;

public class Java8Tester {
   public static void main(String args[]){
      List names = new ArrayList();
  
      names.add("Mahesh");
      names.add("Suresh");
      names.add("Ramesh");
      names.add("Naresh");
      names.add("Kalpesh");
  
      names.forEach(System.out::println);
   }
}	

</pre>
<hr style="border-top: 1px;" />
<pre>

Vector or ArrayList -- which is better?

Sometimes Vector is better; sometimes ArrayList is better; sometimes you don't want to use either. I hope you weren't looking for an easy answer because the answer depends upon what you are doing. There are four factors to consider:

API
Synchronization
Data growth
Usage patterns
Let's explore each in turn.

API

In The Java Programming Language (Addison-Wesley, June 2000) Ken Arnold, James Gosling, and David Holmes describe the Vector as an analog to the ArrayList. So, from an API perspective, the two classes are very similar. However, there are still some major differences between the two classes.

Synchronization

Vectors are synchronized. Any method that touches the Vector's contents is thread safe. ArrayList, on the other hand, is unsynchronized, making them, therefore, not thread safe. With that difference in mind, using synchronization will incur a performance hit. So if you don't need a thread-safe collection, use the ArrayList. Why pay the price of synchronization unnecessarily?

Data growth

Internally, both the ArrayList and Vector hold onto their contents using an Array. You need to keep this fact in mind while using either in your programs. When you insert an element into an ArrayList or a Vector, the object will need to expand its internal array if it runs out of room. A Vector defaults to doubling the size of its array, while the ArrayList increases its array size by 50 percent. Depending on how you use these classes, you could end up taking a large performance hit while adding new elements. It's always best to set the object's initial capacity to the largest capacity that your program will need. By carefully setting the capacity, you can avoid paying the penalty needed to resize the internal array later. If you don't know how much data you'll have, but you do know the rate at which it grows, Vector does possess a slight advantage since you can set the increment value.

Usage patterns

Both the ArrayList and Vector are good for retrieving elements from a specific position in the container or for adding and removing elements from the end of the container. All of these operations can be performed in constant time -- O(1). However, adding and removing elements from any other position proves more expensive -- linear to be exact: O(n-i), where n is the number of elements and i is the index of the element added or removed. These operations are more expensive because you have to shift all elements at index i and higher over by one element. So what does this all mean?

It means that if you want to index elements or add and remove elements at the end of the array, use either a Vector or an ArrayList. If you want to do anything else to the contents, go find yourself another container class. For example, the LinkedList can add or remove an element at any position in constant time -- O(1). However, indexing an element is a bit slower -- O(i) where i is the index of the element. Traversing an ArrayList is also easier since you can simply use an index instead of having to create an iterator. The LinkedList also creates an internal object for each element inserted. So you have to be aware of the extra garbage being created.

Finally, in "PRAXIS 41" from Practical Java (Addison-Wesley, Feb. 2000) Peter Haggar suggests that you use a plain old array in place of either Vector or ArrayList -- especially for performance-critical code. By using an array you can avoid synchronization, extra method calls, and suboptimal resizing. You just pay the cost of extra development time.

</pre>
<hr style="border-top: 1px;" />
<pre>

What to do when your eclipse maven project shows errors in eclipse and compiled successfully !!!!

When your Maven eclipse project shows errors in eclipse editor and it can compile with eclipse or console at that time there must be project configuration issue with eclipse happened, when you open close multiple projects its happens sometime with eclipse.

do

mvn eclipse : eclipse

from your command line by closing eclipse and open eclipse again and refresh projects, error will go away!

</pre>
<hr style="border-top: 1px;" />

<pre>

<a name="Java7sNewFeatures" href="#Java7sNewFeatures" >Java 7's new Features</a>


There are a number of features in Java 7 that will please developers. Things such as strings in switch statements, multi-catch exception handling, try-with-resource statements, the new File System API, extensions of the JVM, support for dynamically-typed languages, the fork and join framework for task parallelism, and a few others will certainly be embraced by the community.
Below I outline the features and provide examples where appropriate. A zip file containing code snippets used in this post can be downloaded here.
Language enhancements
Java 7 includes a few new language features via Project Coin. These features are quite handy for a developer.
Diamond Operator
You may have noted on many occasions your IDE complaining of types when working with Generics. For example, if we have to declare a map of trades using Generics, we write the code as follows:

Map<String, List<Trade>> trades = new TreeMap<String, List<Trade>> ();

The not-so-nice thing about this declaration is that we must declare the types on both the sides, although the right-hand side seems a bit redundant. Can the compiler infer the types by looking at the left-hand-side declaration? Not unless you’re using Java 7. In 7, it’s written like this:

Map<String, List<Trade>> trades = new TreeMap <> ();

How cool is that? You don’t have to type the whole list of types for the instantiation. Instead you use the <> symbol, which is called diamond operator. Note that while not declaring the diamond operator is legal, as trades = new TreeMap (), it will make the compiler generate a couple of type-safety warnings.
Using strings in switch statements
Switch statements work either with primitive types or enumerated types. Java 7 introduced another type that we can use in Switch statements: the String type.
Say we have a requirement to process a Trade based on its status. Until now we used to do this by using if-else statements.

private void processTrade(Trade t) {

            String status = t.getStatus();

            if (status.equalsIgnoreCase(NEW)) {

                  newTrade(t);

            } else if (status.equalsIgnoreCase(EXECUTE)) {

                  executeTrade(t);

            } else if (status.equalsIgnoreCase(PENDING)) {

                  pendingTrade(t);

            }

}

This method of working on strings is crude. In Java 7, we can improve the program by utilizing the enhanced Switch statement, which takes a String type as an argument.

 public void processTrade(Trade t) {

            String status = t.getStatus();



            switch (status) {

            case NEW:

                  newTrade(t);

                  break;

            case EXECUTE:

                  executeTrade(t);

                  break;

            case PENDING:

                  pendingTrade(t);

                  break;



            default:

                  break;

            }

      }
      

In the above program, the status field is always compared against the case label by using theString.equals() method.
Automatic resource management
Resources such as Connections, Files, Input/OutStreams, etc. should be closed manually by the developer by writing bog-standard code. Usually we use a try-finally block to close the respective resources. See the current practice of creating a resource, using it and finally closing it:

public void oldTry() {

            try {

                  fos = new FileOutputStream("movies.txt");

                  dos = new DataOutputStream(fos);

                  dos.writeUTF("Java 7 Block Buster");

            } catch (IOException e) {

                  e.printStackTrace();

            } finally {

                  try {

                        fos.close();

                        dos.close();

                  } catch (IOException e) {

                        // log the exception

                  }

            }

      }

However, Java 7 has introduced another cool feature to manage the resources automatically. It is simple in operation, too. All we have to do is declare the resources in the try as follows:

try(resources_to_be_cleant){

   // your code

}

The above method with the old try can finally can be re-written using this new feature as shown below:

      public void newTry() {



            try (FileOutputStream fos = new FileOutputStream("movies.txt");

                        DataOutputStream dos = new DataOutputStream(fos)) {

                  dos.writeUTF("Java 7 Block Buster");

            } catch (IOException e) {

                  // log the exception

            }

      }

The above code also represents another aspect of this feature: working with multiple resources. The FileOutputStream and DataOutputStream resources are enclosed in the try statement one after the other, each one separated by a semicolon (;) separator. We do not have to nullify or close the streams manually, as they are closed automatically once the control exists the try block.
Behind the scenes, the resources that should be auto closed must implementjava.lang.AutoCloseable interface.
Any resource that implements AutoCloseble interface can be a candidate for automatic resource management. The AutoCloseable is the parent of java.io.Closeable interface and has just one method close() that would be called by the JVM when the control comes out of the try block.
Numeric literals with underscores
Numerical literals are definitely eye strainers. I am sure you would start counting the zeroes like me if you’ve been given a number with, say, ten zeros. It’s quite error prone and cumbersome to identify a literal if it’s a million or a billion unless you count the places from right to left. Not anymore. Java 7 introduced underscores in identifying the places. For example, you can declare 1000 as shown below:

int thousand =  1_000;

or 1000000 (one million) as follows

int million  =  1_000_000

Note that binary literals are also introduced in this release too — for example “0b1″ — so developers don’t have to convert them to hexadecimals any more.
Improved exception handling
There are a couple of improvements in the exception handling area. Java 7 introduced multi-catch functionality to catch multiple exception types using a single catch block.
Let’s say you have a method that throws three exceptions. In the current state, you would deal them individually as shown in below:

   public void oldMultiCatch() {

            try {

                  methodThatThrowsThreeExceptions();

            } catch (ExceptionOne e) {

                  // log and deal with ExceptionOne

            } catch (ExceptionTwo e) {

                  // log and deal with ExceptionTwo

            } catch (ExceptionThree e) {

                  // log and deal with ExceptionThree

            }

      }
      

Catching an endless number of exceptions one after the other in a catch block looks cluttered. And I have seen code that catches a dozen exceptions, too. This is incredibly inefficient and error prone. Java 7 has brought in a new language change to address this ugly duckling. See the improved version of the method oldMultiCatch method below:

      public void newMultiCatch() {

            try {

                  methodThatThrowsThreeExceptions();

            } catch (ExceptionOne | ExceptionTwo | ExceptionThree e) {

                  // log and deal with all Exceptions

            }

      }

The multiple exceptions are caught in one catch block by using a ‘|’ operator. This way, you do not have to write dozens of exception catches. However, if you have bunch of exceptions that belong to different types, then you could use “multi multi-catch” blocks too. The following snippet illustrates this:

public void newMultiMultiCatch() {

            try {

                  methodThatThrowsThreeExceptions();

            } catch (ExceptionOne e) {

                  // log and deal with ExceptionOne



            } catch (ExceptionTwo | ExceptionThree e) {

                  // log and deal with ExceptionTwo and ExceptionThree

            }



      }

In the above case, the ExceptionTwo and ExceptionThree belong to a different hierarchy, so you would want to handle them differently but with a single catch block.
New file system API (NIO 2.0)
Those who worked with Java IO may still remember the headaches that framework caused. It was never easy to work seamlessly across operating systems or multi-file systems. There were methods such as delete or rename that behaved unexpected in most cases. Working with symbolic links was another issue. In an essence, the API needed an overhaul.
With the intention of solving the above problems with Java IO, Java 7 introduced an overhauled and in many cases new API.
The NIO 2.0 has come forward with many enhancements. It’s also introduced new classes to ease the life of a developer when working with multiple file systems.
Working with Path
A new java.nio.file package consists of classes and interfaces such as Path, Paths,FileSystem, FileSystems and others.
A Path is simply a reference to a file path. It is the equivalent (and with more features) tojava.io.File. The following snippet shows how to obtain a path reference to the “temp” folder:

public void pathInfo() {

            Path path = Paths.get("c:\Temp\temp");

System.out.println("Number of Nodes:" + path.getNameCount());

            System.out.println("File Name:" + path.getFileName());

            System.out.println("File Root:" + path.getRoot());

            System.out.println("File Parent:" + path.getParent());

      }

The console output would be:

Number of Nodes:2

File Name:temp.txt

File Root:c:

File Parent:c:Temp

Deleting a file or directory is as simple as invoking a delete method on Files (note the plural) class. The Files class exposes two delete methods, one that throws NoSuchFileException and the other that does not.
The following delete method invocation throws NoSuchFileException, so you have to handle it:

Files.delete(path);

Where as Files.deleteIfExists(path) does not throw exception (as expected) if the file/directory does not exist.
You can use other utility methods such as Files.copy(..) and Files.move(..) to act on a file system efficiently. Similarly, use the createSymbolicLink(..) method to create symbolic links using your code.
File change notifications
One of my favorite improvements in the JDK 7 release is the addition of File Change Notifications. This has been a long-awaited feature that’s finally carved into NIO 2.0. TheWatchService API lets you receive notification events upon changes to the subject (directory or file).
The steps involved in implementing the API are:

    Create a WatchService. This service consists of a queue to hold WatchKeys
    Register the directory/file you wish to monitor with this WatchService
    While registering, specify the types of events you wish to receive (create, modify or delete events)
    You have to start an infinite loop to listen to events
    When an event occurs, a WatchKey is placed into the queue
    Consume the WatchKey and invoke queries on it

Let’s follow this via an example. We create a DirPolice Java program whose responsibility is to police a particular directory. The steps are provided below:
1. Creating a WatchService object:

WatchService  watchService = FileSystems.getDefault().newWatchService();

2. Obtain a path reference to your watchable directory. I suggest you parameterize this directory so you don’t hard code the file name.

path = Paths.get("C:\Temp\temp\");

3. The next step is to register the directory with the WatchService for all types of events:

dirToWatch.register(watchService, ENTRY_CREATE, ENTRY_MODIFY,

ENTRY_DELETE);

These are java.nio.file.StandardWatchEventKinds event types
4. Initiate the infinite loop and start taking the events:

while(true)

{

    WatchKey key = watchService.take(); // this would return you keys

    …

}

5. Run through the events on the key:

for (WatchEvent<?> event : key.pollEvents()) {

            Kind<?> kind = event.kind();

System.out.println("Event on " + event.context().toString() + " is " + kind);

}

For example, if you modify or delete the temp directory, you would see statement as shown below on the console respectively:

Event on temp is ENTRY_MODIFY

Event on temp is ENTRY_DELETE

The relevant methods of the DirPolice source code are posted below (download the full source code):

/**

 * This initiates the police

 */

private void init() {

      path = Paths.get("C:\Temp\temp\");

      try {

            watchService = FileSystems.getDefault().newWatchService();

            path.register(watchService, ENTRY_CREATE, ENTRY_DELETE,

                        ENTRY_MODIFY);

      } catch (IOException e) {

            System.out.println("IOException"+ e.getMessage());

      }

}

/**

 * The police will start making rounds

 */

private void doRounds() {

      WatchKey key = null;

      while(true) {

            try {

                  key = watchService.take();

                  for (WatchEvent<?> event : key.pollEvents()) {

                        Kind<?> kind = event.kind();

System.out.println("Event on " + event.context().toString() + " is " + kind);

                  }

            } catch (InterruptedException e) {

System.out.println("InterruptedException: "+e.getMessage());

            }

            boolean reset = key.reset();

            if(!reset)

                  break;

      }

}

Fork and Join
The effective use of parallel cores in a Java program has always been a challenge. There were few home-grown frameworks that would distribute the work across multiple cores and then join them to return the result set. Java 7 has incorporated this feature as a Fork and Join framework.
Basically the Fork-Join breaks the task at hand into mini-tasks until the mini-task is simple enough that it can be solved without further breakups. It’s like a divide-and-conquer algorithm. One important concept to note in this framework is that ideally no worker thread is idle. They implement a work-stealing algorithm in that idle workers “steal” the work from those workers who are busy.
The core classes supporting the Fork-Join mechanism are ForkJoinPool and ForkJoinTask. TheForkJoinPool is basically a specialized implementation of ExecutorService implementing thework-stealing algorithm we talked about above.
We create an instance of ForkJoinPool by providing the target parallelism level — the number of processors as shown below:

ForkJoinPool pool = new ForkJoinPool(numberOfProcessors)

Where numberOfProcessors = Runtime.getRunTime().availableProcessors();
However, the default ForkJoinPool instantiation would set the parallelism level equal to the same number obtained as above.
The problem that needs to be solved is coded in a ForkJoinTask. However, there are two implementations of this class out of the box: the RecursiveAction and RecursiveTask. The only difference between these two classes is that the former one does not return a value while the latter returns an object of specified type.
Here’s how to create a RecursiveAction or RecursiveTask class that represents your requirement problem (I use the RecursiveAction class):

public class MyBigProblemTask extends RecursiveAction {



    @Override

    protected void compute() {

        . . . // your problem invocation goes here

    }

}

You have to override the compute method where in you need to provide the computing functionality. Now, provide this ForkJoinTask to the Executor by calling invoke method on theForkJoinPool:

pool.invoke(task);

Supporting dynamism
Java is a statically typed language — the type checking of the variables, methods and return values is performed at compile time. The JVM executes this strongly-typed bytecode at runtime without having to worry about finding the type information.
There’s another breed of typed languages — the dynamically typed languages. Ruby, Python and Clojure are in this category. The type information is unresolved until runtime in these languages. This is not possible in Java as it would not have any necessary type information.
There is an increasing pressure on Java folks improvise running the dynamic languages efficiently. Although it is possible to run these languages on a JVM (using Reflection), it’s not without constraints and restrictions.
In Java 7, a new feature called invokedynamic was introduced. This makes VM changes to incorporate non-Java language requirements. A new package, java.lang.invoke, consisting of classes such as MethodHandle, CallSite and others, has been created to extend the support of dynamic languages.


</pre>
<hr style="border-top: 1px;" />
<pre>

<a name="javalangOutOfMemoryError" href="#javalangOutOfMemoryError" >What is java.lang.OutOfMemoryError in Java ?</a>

 

OutOfMemoryError in Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it ran out of memory in the heap. OutOfMemoryError in Java can come anytime in heap mostly while you try to create an object and there is not enough space on the heap to allocate that object. Javadoc of OutOfMemoryError is not very informative about this, though.

I have seen mainly two types of OutOfMemoryError in Java:

1) The java.lang.OutOfMemoryError: Java heap space
2) The java.lang.OutOfMemoryError: PermGen space

Though both of them occur because JVM ran out of memory they are quite different to each other and their solutions are independent of each other.


Since in most of JVM default size of Perm Space is around "64MB" you can easily run out of memory if you have too many classes or a huge number of Strings in your project.

How to solve java.lang.OutOfMemoryError: Java heap space

1) An easy way to solve OutOfMemoryError in java is to increase the maximum heap size by using JVM options "-Xmx512M", this will immediately solve your OutOfMemoryError. This is my preferred solution when I get OutOfMemoryError in Eclipse, Maven or ANT while building project because based upon size of project you can easily run out of Memory.here is an example of increasing maximum heap size of JVM, Also its better to keep -Xmx to -Xms ration either 1:1 or 1:1.5 if you are setting heap size in your java application

export JVM_ARGS="-Xms1024m -Xmx1024m"

2) The second way to resolve OutOfMemoryError in Java is rather hard and  comes when you don't have much memory and even after increase maximum heap size you are still getting java.lang.OutOfMemoryError, in this case, you probably want to profile your application and look for any memory leak. You can use Eclipse Memory Analyzer to examine your heap dump or you can use any profiler like Netbeans or JProbe. This is tough solution and requires some time to analyze and find memory leaks.

How to solve java.lang.OutOfMemoryError: PermGen space
As explained in above paragraph this OutOfMemory error in java comes when Permanent generation of heap filled up. To fix this OutOfMemoryError in Java, you need to increase heap size of Perm space by using JVM option   "-XX: MaxPermSize". You can also specify initial size of Perm space by using    "-XX: PermSize" and keeping both initial and maximum Perm Space you can prevent some full garbage collection which may occur when Perm Space gets re-sized. Here is how you can specify initial and maximum Perm size in Java:

export JVM_ARGS="-XX:PermSize=64M -XX:MaxPermSize=256m"

Some time java.lang.OutOfMemoryError  in Java gets tricky and on those cases profiling remains ultimate solution.Though you have the freedom to increase heap size in java, it’s recommended that to follow memory management practices while coding and setting null to any unused references.



<hr style="border-top: 1px;" />

<a name="PrintStringsInSequenceWithMultipleThreads" href="#PrintStringsInSequenceWithMultipleThreads" >Print strings in sequence with multiple threads </a>

public class MTest {

	public static void main(String[] args) throws InterruptedException {
		
		Thread t1 = new Thread(new Runnable() {
			public void run() {
				for (int i = 0; i < 1000; i ++) {
					System.out.println("hello " +  i);
				}				
			}
		});
		
		Thread t2 = new Thread(new Runnable() {
			public void run() {
				System.out.println("firstName");
			}
		});
		
		Thread t3 = new Thread(new Runnable() {
			public void run() {
				System.out.println("lastName");
			}
		});
		
		t1.start();
		t1.join();
		t2.start();
		t2.join();
		t3.start();
		
	}
	
}

<hr style="border-top: 1px;" />

<a name="createDeadLock" href="#createDeadLock" >Create DeadLock in Java</a>

public class MyDeadlock {
 
    String str1 = "Java";
    String str2 = "UNIX";
     
    Thread trd1 = new Thread("My Thread 1"){
        public void run(){
            while(true){
                synchronized(str1){
                    synchronized(str2){
                        System.out.println(str1 + str2);
                    }
                }
            }
        }
    };
     
    Thread trd2 = new Thread("My Thread 2"){
        public void run(){
            while(true){
                synchronized(str2){
                    synchronized(str1){
                        System.out.println(str2 + str1);
                    }
                }
            }
        }
    };
     
    public static void main(String a[]){
        MyDeadlock mdl = new MyDeadlock();
        mdl.trd1.start();
        mdl.trd2.start();
    }
}

<hr style="border-top: 1px;" />

<a name="ThreadPoolExecutor" href="#ThreadPoolExecutor" >ThreadPoolExecutor</a>

The java.util.concurrent.ThreadPoolExecutor is an implementation of the ExecutorService interface. The ThreadPoolExecutor executes the given task (Callable or Runnable) using one of its internally pooled threads.

The thread pool contained inside the ThreadPoolExecutor can contain a varying amount of threads. The number of threads in the pool is determined by these variables:

corePoolSize
maximumPoolSize
If less than corePoolSize threads are created in the the thread pool when a task is delegated to the thread pool, then a new thread is created, even if idle threads exist in the pool.

If the internal queue of tasks is full, and corePoolSize threads or more are running, but less than maximumPoolSize threads are running, then a new thread is created to execute the task.

Here is a diagram illustrating the ThreadPoolExecutor principles:

<img src="data:image/png;base64,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"/>

However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class, as shown in the ExecutorService text.

ExecutorService Example
Here is a simple Java ExectorService example:

ExecutorService executorService = Executors.newFixedThreadPool(10);

executorService.execute(new Runnable() {
    public void run() {
        System.out.println("Asynchronous task");
    }
});

executorService.shutdown();
First an ExecutorService is created using the newFixedThreadPool() factory method. This creates a thread pool with 10 threads executing tasks.

Second, an anonymous implementation of the Runnable interface is passed to the execute() method. This causes the Runnable to be executed by one of the threads in the ExecutorService.

<hr style="border-top: 1px;" />

<a name="LifeCycleOfAThread" href="#LifeCycleOfAThread" >Life cycle of a Thread (Thread States)</a>

A thread can be in one of the five states. According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state.

But for better understanding the threads, we are explaining it in the 5 states.

The life cycle of the thread in java is controlled by JVM. The java thread states are as follows:
1. New
2. Runnable
3. Running
4. Non-Runnable (Blocked)
5. Terminated

<img src="data:image/jpeg;base64,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"/>

1) New
The thread is in new state if you create an instance of Thread class but before the invocation of start() method.

2) Runnable
The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread.

3) Running
The thread is in running state if the thread scheduler has selected it.

4) Non-Runnable (Blocked)
This is the state when the thread is still alive, but is currently not eligible to run.

5) Terminated
A thread is in terminated or dead state when its run() method exits.


<hr style="border-top: 1px;" />

<a name="yieldMethod" href="#yieldMethod" >Java.lang.Thread.yield() Method</a>

Description
The java.lang.Thread.yield() method causes the currently executing thread object to temporarily pause and allow other threads to execute.

Declaration
Following is the declaration for java.lang.Thread.yield() method

public static void yield()
Parameters
NA

Return Value
This method does not return any value.

Exception

Example

import java.lang.*;

public class ThreadDemo implements Runnable {

   Thread t;

   ThreadDemo(String str) {

      t = new Thread(this, str);
      // this will call run() function
      t.start();
   }

   public void run() {

      for (int i = 0; i < 5; i++) {
         // yields control to another thread every 5 iterations
         if ((i % 5) == 0) {
            System.out.println(Thread.currentThread().getName() + "
            yielding control...");

            /* causes the currently executing thread object to temporarily 
            pause and allow other threads to execute */
            Thread.yield();
         }
      }

      System.out.println(Thread.currentThread().getName() + " has finished executing.");
   }

   public static void main(String[] args) {
      new ThreadDemo("Thread 1");
      new ThreadDemo("Thread 2");
      new ThreadDemo("Thread 3");
   }
}

output-- 

Thread 1 is yielding control...
Thread 2 is yielding control...
Thread 3 is yielding control...
Thread 1 has finished executing.
Thread 2 has finished executing.
Thread 3 has finished executing.


<hr style="border-top: 1px;" />

<a name="joinMethod" href="#joinMethod" >Java.lang.Thread.join() Method</a>

Description
The java.lang.Thread.join() method waits for this thread to die.

Declaration
Following is the declaration for java.lang.Thread.join() method

public final void join() throws InterruptedException

Parameters
NA

Return Value
This method does not return any value.

Exception
InterruptedException − if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.

Example

import java.lang.*;

public class ThreadDemo implements Runnable {

   public void run() {
   
      Thread t = Thread.currentThread();
      System.out.print(t.getName());
      
      //checks if this thread is alive
      System.out.println(", status = " + t.isAlive());
   }

   public static void main(String args[]) throws Exception {
   
      Thread t = new Thread(new ThreadDemo());
      
      // this will call run() function
      t.start();
      
      // waits for this thread to die
      t.join();
      System.out.print(t.getName());
      
      //checks if this thread is alive
      System.out.println(", status = " + t.isAlive());
   }
} 

Output -

Thread-0, status = true
Thread-0, status = false

join method with time arguments

    /**
     * Waits at most {@code millis} milliseconds for this thread to
     * die. A timeout of {@code 0} means to wait forever.
     *
     * This implementation uses a loop of {@code this.wait} calls
     * conditioned on {@code this.isAlive}. As a thread terminates the
     * {@code this.notifyAll} method is invoked. It is recommended that
     * applications not use {@code wait}, {@code notify}, or
     * {@code notifyAll} on {@code Thread} instances.
     *
     * @param  millis
     *         the time to wait in milliseconds
     *
     * @throws  IllegalArgumentException
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          if any thread has interrupted the current thread. The
     *          <i>interrupted status</i> of the current thread is
     *          cleared when this exception is thrown.
     */
    public final synchronized void join(long millis)



<hr style="border-top: 1px;" />

<a name="PreemptiveSchedulingVsTimeSlicing" href="#PreemptiveSchedulingVsTimeSlicing" >What is the difference between preemptive scheduling and time slicing?</a>

Preemptive scheduling: The highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. 
Time slicing: A task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.

<hr style="border-top: 1px;" />


What is Inheritance in Java ?
Inheritance in Java or OOPS (Object oriented programming) is a feature which allows coding reusability.  In other words, Inheritance  self-implies inheriting or we can say acquiring something from others. Along with Abstraction, Encapsulation and Polymorphism, Inheritance forms the backbone of Object oriented programming and Java.  In Java, we use the term inheritance when one object acquires some property from other objects. In Java, inheritance is defined in terms of superclass and subclass. it is normally used when some object wants to use existing feature of some class and also want to provide some special feature, so we can say inheritance has given the advantage of reusability.

By using Inheritance between Superclass and Subclass, a IS-A Relationship is formed which means you can use any subclass object in place of the super class object e.g. if a method expects a superclass object, you can pass a subclass object to it. Inheritance in Java is also used to provide a concrete implementation of abstract class and interface in Java.


 Inheritance in Java- Things to remember
Here are some important points about Inheritance in Java which is worth remembering:

    One subclass can extend only one super class in Java but it can implement the multiple interfaces.
    A private member of the super class can not be inherited in subclass e.g. private field and private methods.
    Default member can only be inherited in same package subclass, not in another package.
    The constructor in Java is not inherited by the subclass.
    If a class implements Interface or extends an abstract class, it needs to override all abstract methods untile it is not abstract.
    Multiple inheritances are not supported in java but we can achieve this by using interface.One class can implement multiple interfaces
    In Java class never extends the interface rather it implements interface
    One interface can extend another interface in Java.

Why multiple inheritances are not supported in Java ?

The diamond problem
A diamond class inheritance diagram.

The "diamond problem" (sometimes referred to as the "deadly diamond of death"[4]) is an ambiguity that arises when two classes B and C inherit from A, and class D inherits from both B and C. If there is a method in A that B and C have overridden, and D does not override it, then which version of the method does D inherit: that of B, or that of C?

For example, in the context of GUI software development, a class Button may inherit from both classes Rectangle (for appearance) and Clickable (for functionality/input handling), and classes Rectangle and Clickable both inherit from the Object class. Now if the equals method is called for a Button object and there is no such method in the Button class but there is an overridden equals method in Rectangle or Clickable (or both), which method should be eventually called?

It is called the "diamond problem" because of the shape of the class inheritance diagram in this situation. In this case, class A is at the top, both B and C separately beneath it, and D joins the two together at the bottom to form a diamond shape.

Java 8 introduces default methods on interfaces. If A,B,C are interfaces, B,C can each provide a different implementation to an abstract method of A, causing the diamond problem. Either class D must reimplement the method (the body of which can simply forward the call to one of the super implementations), or the ambiguity will be rejected as a compile error.[6] Prior to Java 8, Java was not subject to the Diamond problem risk, as Java does not support multiple inheritance.


How hashmap works in java?

Single statement answer

If anybody asks me to describe “How HashMap works?“, I simply answer: “On principle of Hashing“. As simple as it is. Now before answering it, one must be very sure to know at least basics of Hashing. Right??

What is Hashing

Hashing in its simplest form, is a way to assigning a unique code for any variable/object after applying any formula/algorithm on its properties. A true Hashing function must follow this rule:

Hash function should return the same hash code each and every time, when function is applied on same or equal objects. In other words, two equal objects must produce same hash code consistently.

All objects in java inherit a default implementation of hashCode() function defined in Object class. This function produce hash code by typically converting the internal address of the object into an integer, thus producing different hash codes for all different objects.

A little about Entry class

A map by definition is : “An object that maps keys to values”. Very easy.. right?

So, there must be some mechanism in HashMap to store this key value pair. Answer is YES. HashMap has an inner class Entry, which looks like this:
static class Entry<K ,V> implements Map.Entry<K ,V>
{
    final K key;
    V value;
    Entry<K ,V> next;
    final int hash;
    ...//More code goes here
}

What put() method actually does

Before going into put() method’s implementation, it is very important to learn that instances of Entry class are stored in an array. HashMap class defines this variable as:
/**
 * The table, resized as necessary. Length MUST Always be a power of two.
 */
transient Entry[] table;

Now look at code implementation of put() method:

/**
* Associates the specified value with the specified key in this map. If the
* map previously contained a mapping for the key, the old value is
* replaced.
*
* @param key
*            key with which the specified value is to be associated
* @param value
*            value to be associated with the specified key
* @return the previous value associated with <tt>key</tt>, or <tt>null</tt>
*         if there was no mapping for <tt>key</tt>. (A <tt>null</tt> return
*         can also indicate that the map previously associated
*         <tt>null</tt> with <tt>key</tt>.)
*/
public V put(K key, V value) {
    if (key == null)
    return putForNullKey(value);
    int hash = hash(key.hashCode());
    int i = indexFor(hash, table.length);
    for (Entry<K , V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
 
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}

Lets note down the steps one by one:

1) First of all, key object is checked for null. If key is null, value is stored in table[0] position. Because hash code for null is always 0.

2) Then on next step, a hash value is calculated using key’s hash code by calling its hashCode() method. This hash value is used to calculate index in array for storing Entry object. JDK designers well assumed that there might be some poorly written hashCode() functions that can return very high or low hash code value. To solve this issue, they introduced another hash() function, and passed the object’s hash code to this hash() function to bring hash value in range of array index size.

3) Now indexFor(hash, table.length) function is called to calculate exact index position for storing the Entry object.

4) Here comes the main part. Now, as we know that two unequal objects can have same hash code value, how two different objects will be stored in same array location [called bucket].
Answer is LinkedList. If you remember, Entry class had an attribute “next”. This attribute always points to next object in chain. This is exactly the behavior of LinkedList.

So, in case of collision, Entry objects are stored in LinkedList form. When an Entry object needs to be stored in particular index, HashMap checks whether there is already an entry?? If there is no entry already present, Entry object is stored in this location.

If there is already an object sitting on calculated index, its next attribute is checked. If it is null, and current Entry object becomes next node in LinkedList. If next variable is not null, procedure is followed until next is evaluated as null.

What if we add the another value object with same key as entered before. Logically, it should replace the old value. How it is done? Well, after determining the index position of Entry object, while iterating over LinkedList on calculated index, HashMap calls equals method on key object for each Entry object. All these Entry objects in LinkedList will have similar hash code but equals() method will test for true equality. If key.equals(k) will be true then both keys are treated as same key object. This will cause the replacing of value object inside Entry object only.

In this way, HashMap ensure the uniqueness of keys.

How get() methods works internally

Now we have got the idea, how key-value pairs are stored in HashMap. Next big question is : what happens when an object is passed in get method of HashMap? How the value object is determined?

Answer we already should know that the way key uniqueness is determined in put() method , same logic is applied in get() method also. The moment HashMap identify exact match for the key object passed as argument, it simply returns the value object stored in current Entry object.

If no match is found, get() method returns null.

Let have a look at code:
/**
* Returns the value to which the specified key is mapped, or {@code null}
* if this map contains no mapping for the key.
*
* <p>
* More formally, if this map contains a mapping from a key {@code k} to a
* value {@code v} such that {@code (key==null ? k==null :
* key.equals(k))}, then this method returns {@code v}; otherwise it returns
* {@code null}. (There can be at most one such mapping.)
*
* </p><p>
* A return value of {@code null} does not <i>necessarily</i> indicate that
* the map contains no mapping for the key; it's also possible that the map
* explicitly maps the key to {@code null}. The {@link #containsKey
* containsKey} operation may be used to distinguish these two cases.
*
* @see #put(Object, Object)
*/
public V get(Object key) {
    if (key == null)
    return getForNullKey();
    int hash = hash(key.hashCode());
    for (Entry<K , V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
            return e.value;
    }
    return null;
}

Above code is same as put() method till if (e.hash == hash && ((k = e.key) == key || key.equals(k))), after this simply value object is returned.

Key Notes

    Data structure to store Entry objects is an array named table of type Entry.
    A particular index location in array is referred as bucket, because it can hold the first element of a LinkedList of Entry objects.
    Key object’s hashCode() is required to calculate the index location of Entry object.
    Key object’s equals() method is used to maintain uniqueness of Keys in map.
    Value object’s hashCode() and equals() method are not used in HashMap’s get() and put() methods.
    Hash code for null keys is always zero, and such Entry object is always stored in zero index in Entry[].

[Update] Improvements in Java 8

As part of the work for JEP 180, there is a performance improvement for HashMap objects where there are lots of collisions in the keys by using balanced trees rather than linked lists to store map entries. The principal idea is that once the number of items in a hash bucket grows beyond a certain threshold, that bucket will switch from using a linked list of entries to a balanced tree. In the case of high hash collisions, this will improve worst-case performance from O(n) to O(log n).

Basically when a bucket becomes too big (currently: TREEIFY_THRESHOLD = 8), HashMap dynamically replaces it with an ad-hoc implementation of tree map. This way rather than having pessimistic O(n) we get much better O(log n).

Bins (elements or nodes) of TreeNodes may be traversed and used like any others, but additionally support faster lookup when overpopulated. However, since the vast majority of bins in normal use are not overpopulated, checking for existence of tree bins may be delayed in the course of table methods.

Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two elements are of the same “class C implements Comparable<C>“, type then their compareTo() method is used for ordering.

Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes. And when they become too small (due to removal or resizing) they are converted back to plain bins (currently: UNTREEIFY_THRESHOLD = 6). In usages with well-distributed user hashCodes, tree bins are rarely used.

I hope, i have correctly communicated my thoughts by this article. If you find any difference or need any help in any point, please drop a comment.

Happy Learning !!

http://howtodoinjava.com/core-java/collections/how-hashmap-works-in-java/

<hr style="border-top: 1px;" />

Working with hashCode and equals methods in java

The general contract of hashCode is:

    Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.
    If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
    It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. 

Usage of hashCode() and equals()

hashCode() method is used to get a unique integer for given object. This integer is used for determining the bucket location, when this object needs to be stored in some HashTable like data structure. By default, Object’s hashCode() method returns and integer representation of memory address where object is stored.

equals() method, as name suggest, is used to simply verify the equality of two objects. Default implementation simply check the object references of two objects to verify their equality.

Overriding the default behavior

Everything works fine until you do not override any of these methods in your classes. But, sometimes application needs to change the default behavior of some objects.

Lets take an example where your application has Employee object. Lets create a minimal possible structure of Employee class::
public class Employee
{
    private Integer id;
    private String firstname;
    private String lastName;
    private String department;
 
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getFirstname() {
        return firstname;
    }
    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    public String getDepartment() {
        return department;
    }
    public void setDepartment(String department) {
        this.department = department;
    }
}

Above Employee class has some very basic attributes and there accessor methods. Now consider a simple situation where you need to compare two employee objects.
public class EqualsTest {
    public static void main(String[] args) {
        Employee e1 = new Employee();
        Employee e2 = new Employee();
 
        e1.setId(100);
        e2.setId(100);
 
        //Prints false in console
        System.out.println(e1.equals(e2));
    }
}

No prize for guessing. Above method will print “false“. But, is it really correct after knowing that both objects represent same employee. In a real time application, this must return true.

To achieve correct behavior, we need to override equals method as below:
public boolean equals(Object o) {
    if(o == null)
    {
        return false;
    }
    if (o == this)
    {
        return true;
    }
    if (getClass() != o.getClass())
    {
        return false;
    }
     
    Employee e = (Employee) o;
    return (this.getId() == e.getId());
     
}

Add this method to your Employee class, and EqualsTest will start returning “true“.

So are we done? Not yet. Lets test again above modified Employee class in different way.
import java.util.HashSet;
import java.util.Set;
 
public class EqualsTest
{
    public static void main(String[] args)
    {
        Employee e1 = new Employee();
        Employee e2 = new Employee();
 
        e1.setId(100);
        e2.setId(100);
 
        //Prints 'true'
        System.out.println(e1.equals(e2));
 
        Set<Employee> employees = new HashSet<Employee>();
        employees.add(e1);
        employees.add(e2);
         
        //Prints two objects
        System.out.println(employees);
    }
}

Above class prints two objects in second print statement. If both employee objects have been equal, in a Set which stores only unique objects, there must be only one instance inside HashSet, after all both objects refer to same employee. What is it we are missing??

We are missing the second important method hashCode(). As java docs say, if you override equals() method then you must override hashCode() method. So lets add another method in our Employee class.
@Override
public int hashCode()
{
    final int PRIME = 31;
    int result = 1;
    result = PRIME * result + getId();
    return result;
}

Once above method is added in Employee class, the second statement start printing only single object in second statement, and thus validating the true equality of e1 and e2.

Overriding hashCode() and equals() using Apache Commons Lang

Apache commons provide two excellent utility classes HashCodeBuilder and EqualsBuilder for generating hash code and equals methods. Below is its usage:
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
public class Employee
{
    private Integer id;
    private String firstname;
    private String lastName;
    private String department;
    public Integer getId() {
        return id;
    }
    public void setId(Integer id) {
        this.id = id;
    }
    public String getFirstname() {
        return firstname;
    }
    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    public String getDepartment() {
        return department;
    }
    public void setDepartment(String department) {
        this.department = department;
    }
    @Override
    public int hashCode()
    {
        final int PRIME = 31;
        return new HashCodeBuilder(getId()%2==0?getId()+1:getId(), PRIME).toHashCode();
    }
    @Override
    public boolean equals(Object o) {
    if (o == null)
       return false;
        
    if (o == this)
       return true;
        
    if (o.getClass() != getClass())
       return false;
     
    Employee e = (Employee) o;
     
    return new EqualsBuilder().
              append(getId(), e.getId()).
              isEquals();
    }
}

Alternatively, if you are using any code editor, they also must be capable of generating some good structure for you. For example, Eclipse IDE has option under right click on class >> source > Generate hashCode() and equals() … will generate a very good implementation for you.

Important things to remember

1) Always use same attributes of an object to generate hashCode() and equals() both. As in our case, we have used employee id.

2) equals() must be consistent (if the objects are not modified, then it must keep returning the same value).

3) Whenever a.equals(b), then a.hashCode() must be same as b.hashCode().

4) If you override one, then you should override the other.

Special Attention When Using in ORM

If you’re dealing with an ORM, make sure to always use getters, and never field references in hashCode() and equals(). This is for reason, in ORM, occasionally fields are lazy loaded and not available until called their getter methods.

For example, In our Employee class if we use e1.id == e2.id. It is very much possible that id field is lazy loaded. So in this case, one might be zero or null, and thus resulting in incorrect behavior.

But if uses e1.getId() == e2.getId(), we can be sure even if field is lazy loaded; calling getter will populate the field first.

This is all i know about hashCode() and equals() methods. I hope, it will help someone somewhere.

If you feel, I am missing something or wrong somewhere, please leave a comment. I will update this post again to help others.

Happy Learning !!

http://howtodoinjava.com/core-java/basics/working-with-hashcode-and-equals-methods-in-java/


Using HashMap in non-synchronized code in multi-threaded application

In normal cases, it can leave the hashmap in inconsistent state where key-value pairs added and retrieved can be different. Apart from this, other surprising behavior like NullPointerException can come into picture.

In worst case, It can cause infinite loop. YES. You got it right. It can cause infinite loop. What did you asked, How?? Well, here is the reason.

HashMap has the concept of rehashing when it reaches to its upper limit of size. This rehashing is the process of creating a new memory area, and copying all the already present key-value pairs in new memory are. Lets say Thread A tried to put a key-value pair in map and then rehashing started. At the same time, thread B came and started manipulating the buckets using put operation.

Here while rehashing process, there are chances to generate the cyclic dependency where one element in linked list [in any bucket] can point to any previous node in same bucket. This will result in infinite loop, because rehashing code contains a “while(true) { //get next node; }” block and in cyclic dependency it will run infinite.

To watch closely, look art source code of transfer method which is used in rehashing:
public Object get(Object key) {
    Object k = maskNull(key);
    int hash = hash(k);
    int i = indexFor(hash, table.length);
    Entry e = table[i];
 
    //While true is always a bad practice and cause infinite loops
 
    while (true) {
        if (e == null)
            return e;
        if (e.hash == hash &amp;&amp; eq(k, e.key))
            return e.value;
        e = e.next;
    }
}

I will write a more detailed article on this in future.

I hope I was able to put some more items on your knowledge bucket. If you find this article helpful, please consider it sharing with your friends.

Happy Learning !!	
	
<hr style="border-top: 1px;" />
	
How can I sort a LinkedHashMap based on its values given that the LinkedHashMap contains of String and Integer. So I need to sort it based on the Values which are Integers.

map.entrySet().stream()
    .sorted(Map.Entry.comparingByValue())
    .forEach(entry -> ... );
	
<hr style="border-top: 1px;" />

<pre>

</div>

</body>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-82393887-1', 'auto');
  ga('send', 'pageview');
  </script>
  
</html>
