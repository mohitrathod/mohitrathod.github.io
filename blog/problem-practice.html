<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="UTF-8">
    <title>Problem Practice</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="https://material.angularjs.org/1.1.1/docs.css" rel='stylesheet' type='text/css' ></link>
    <link rel="stylesheet" type="text/css" href="/stylesheets/normalize.css" media="screen">
	<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Inconsolata" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheets/github-light.css" media="screen">
	<link rel="stylesheet" type="text/css" href="/stylesheets/custom.css" media="screen">

  </head>

<body>

<div style="padding-left: 2%; padding-right: 2%;">

<h1 align="center" > Problem Practice </h1>


<hr>


<pre>

<a name="find-first-unrepeated-letter" href="#find-first-unrepeated-letter" >In a given word find the first un-repeated  letter, e.g., in ‘total’ its ‘o’ and in ‘ teeter’ its ‘r’.</a>



import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;

/**
 * @author mohit
 *
 * In a given word find the first un-repeated  letter, e.g., in ‘total’ its ‘o’ and in ‘ teeter’ its ‘r’.
 *
 */
public class FirstUnrepeatedLetter {


	public static void main(String[] args) {

		firstUnrepeatedLetter("total");

		firstUnrepeatedLetter("teeter");

	}


	public static void firstUnrepeatedLetter (String s1) {

		String input = s1;

		Map<Character, Boolean> charOccouranceMap = new LinkedHashMap<>();

		for(Character c : input.toCharArray()) {

			if(charOccouranceMap.containsKey(c)) {
				charOccouranceMap.put(c, true);
			}else {
				charOccouranceMap.put(c, false);
			}

		}

		for (Entry<Character, Boolean> entry : charOccouranceMap.entrySet()) {
			if(entry.getValue()) {
				continue;
			} else {
				System.out.println(entry.getKey());
				break;
			}
		}

	}

}


<hr style="border-top: 1px;" />

<a name="reverse-linkedlist" href="#reverse-linkedlist" >Reverse the LinkedList</a>


public class ReverseLinkedList {


    private static class SinglyLinkedList {

        Node head;



        // prints content of double linked list
        void printList(Node node) {
            while (node != null) {
                System.out.print(node.data + " ");
                node = node.next;
            }
        }



        Node reverseV2( Node node, Node previous) {

//	    	System.out.println(node.data + "->" + (previous == null ? "null" : previous.data) );

            if ( node.next != null) {

                Node next1 = node.next;

                node.next = previous;

                return reverseV2(next1, node);

            } else {

                node.next = previous;
                return node;

            }


        }

    }


    private static class Node {

        int data;
        Node next;
        Node(int d) {
            data = d;
        }

    }


    public static void main(String[] args) {


        SinglyLinkedList list = new SinglyLinkedList();
        list.head = new Node(1);
        list.head.next = new Node(2);
        list.head.next.next = new Node(3);
        list.head.next.next.next = new Node(4);

        System.out.println("Original Linked list is :");
        list.printList(list.head);
        System.out.println("");
        list.head = list.reverseV2(list.head, null);
        System.out.println("");
        System.out.println("Reversed linked list : ");
        list.printList(list.head);
    }

}

debug points

linklist null->1->2->3->4

reverse(1,null)
next1 2,
1->null
reverse(2, 1)
next1 3,
2->1->null
reverse(3, 2)
next1 4,
3->2->1->null
reverse(4, 3)
4->3->2->1->null
return 4

<hr style="border-top: 1px;" />


<a name="shortest-path-in-matrix-problem-java-solution" href="#shortest-path-in-matrix-problem-java-solution" >Shortest Path in Matrix Problem Java solution  </a>


import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class ShortestPathMatrix {

	Set<MatrixElement> elements = new HashSet<>();

	Map<String, MatrixElement> locationMap = new HashMap<>();

	public void createMatrix () {

	  /*	1	2	3
		4	5	6
		7	8	9
		10	11	13	*/


		String matrix = "(0,0)1 \n " +
				"(0,1)2 \n " +
				"(0,2)3 \n " +
				"(1,0)4 \n " +
				"(1,1)5 \n " +
				"(1,2)6 \n " +
				"(2,0)7 \n " +
				"(2,1)8 \n " +
				"(2,2)9 \n " +
				"(3,0)10 \n " +
				"(3,1)11 \n " +
				"(3,2)12 \n " +
				"(4,0)13 \n " +
				"(4,1)14 \n " +
				"(4,2)15 \n " ;

		int id = 0;
		for (String element : matrix.split("\\n")) {

			if(element.trim().length() > 0) {

				MatrixElement matrixElement = new MatrixElement();
				matrixElement.setId(id);
				matrixElement.setValue(element.split("\\)")[1]);
				matrixElement.setCordX(Integer.parseInt(element.split(",")[0].replace("(", "").trim()));
				matrixElement.setCordY(Integer.parseInt(element.split(",")[1].split("\\)")[0]));
				elements.add(matrixElement);
				locationMap.put(matrixElement.getCordX()+","+matrixElement.getCordY(), matrixElement);
				id++;

			}



		}

	}


	public static void main(String[] args) {

		ShortestPathMatrix matrix = new ShortestPathMatrix();

		matrix.createMatrix();

		matrix.findDistanceBetweenPoint("4,1", "0,0");



	}


	private void findDistanceBetweenPoint(String string, String string2) {

		MatrixElement a = locationMap.get(string);
		MatrixElement b = locationMap.get(string2);

		int x, y;

		x = a.getCordX();
		y = a.getCordY();


		locateTheItem(x, y, b);

	}

	private void locateTheItem(int x, int y, MatrixElement b) {

		System.out.println(x + " , " + y);

		int nextX = x;
		int nextY = y;

		boolean locateAgain = false;

		if(b.getCordX() > x) {
			nextX = x + 1;
			locateAgain = true;
		}

		if (b.getCordY() > y ) {
			nextY = y + 1;
			locateAgain = true;
		}

		if(b.getCordX() < x) {
			nextX = x - 1;
			locateAgain = true;
		}

		if (b.getCordY() < y ) {
			nextY = y - 1;
			locateAgain = true;
		}


		if(locateAgain) {
			locateTheItem(nextX, nextY, b);
		} else {

			System.out.println("traced !");

		}


	}

	public class MatrixElement {

		private int id;
		private String value;

		private MatrixElement left;
		private MatrixElement right;
		private MatrixElement top;
		private MatrixElement bottom;

		private int cordX;
		private int cordY;


		public MatrixElement getLeft() {
			return left;
		}
		public void setLeft(MatrixElement left) {
			this.left = left;
		}
		public MatrixElement getRight() {
			return right;
		}
		public void setRight(MatrixElement right) {
			this.right = right;
		}
		public MatrixElement getTop() {
			return top;
		}
		public void setTop(MatrixElement top) {
			this.top = top;
		}
		public MatrixElement getBottom() {
			return bottom;
		}
		public void setBottom(MatrixElement bottom) {
			this.bottom = bottom;
		}
		public int getId() {
			return id;
		}
		public void setId(int id) {
			this.id = id;
		}
		public String getValue() {
			return value;
		}
		public void setValue(String value) {
			this.value = value;
		}
		public int getCordX() {
			return cordX;
		}
		public void setCordX(int cordX) {
			this.cordX = cordX;
		}
		public int getCordY() {
			return cordY;
		}
		public void setCordY(int cordY) {
			this.cordY = cordY;
		}



	}


}


<hr style="border-top: 1px;" />



<a name="union-of-two-sorted-array" href="#union-of-two-sorted-array" >Union Of Two Sorted Array problem or Merge two sorted arrays</a>



import java.util.Arrays;

public class UnionOfTwoSortedArray {

	public static void main(String[] args) {

		int [] arr1 = {1,3,4,5,7};
		int [] arr2 = {2,3,5,6};

		int i = arr1.length;
		int j = arr2.length;

		int [] unionArray = new int [i + j];

		int x = 0;
		int y = 0;

		int g = 0;

		while (x < i && y < j) {


			if (arr1[x] < arr2[y]) {

				unionArray[g] = arr1[x];
				g++;
				x++;


			} else if (arr1[x] > arr2[y]) {

				unionArray[g] = arr2[y];
				g++;
				y++;


			} else if (arr1[x] == arr2[y]) {

				unionArray[g] = arr1[x];
				x++;
				y++;
				g++;
			}

		}

		while(x < i)
		unionArray[g++] = arr1[x++];
		while(y < j)
		unionArray[g++] = arr1[y++];


		System.out.println(Arrays.toString(unionArray));

	}

}


<hr style="border-top: 1px;" />


<a name="ransom-note" href="#ransom-note" >Untraceable ransom note</a>

A kidnapper wrote a ransom note but is worried it will be traced back to him. He found a magazine and wants to know if he can cut out whole words from it and use them to create an untraceable replica of his ransom note. The words in his note are case-sensitive and he must use whole words available in the magazine, meaning he cannot use substrings or concatenation to create the words he needs.
Given the words in the magazine and the words in the ransom note, print Yes if he can replicate his ransom note exactly using whole words from the magazine; otherwise, print No.

from collections import Counter

def ransom_note(magazine, ransom):
  return not (Counter(rasom) - Counter(magazine))

m, n = map(int, input().strip().split(' '))
magazine = input().strip().split(' ')
ransom = input().strip().split(' ')
answer = ransom_note(magazine, ransom)
if(answer):
    print("Yes")
else:
    print("No")

-----

Sample Input 0

6 4
give me one grand today night
give one grand today

Sample Output 0

Yes

-----

Sample Input 1

6 5
two times three is not four
two times two is four

Sample Output 1

No

-----


<hr style="border-top: 1px;" />


<a name="program-to-print-column-names-of-excel" href="#program-to-print-column-names-of-excel" >Program to print column names of excel eg. a, b ... ab, ac ... az, ba ... azz, caa</a>


def incrementString(str1):
    arr = list(str1)
    arr.reverse()

    if ord(arr[0]) - ord('a') + 1 == 26:
        arr[0] = 'a'
        if str1[:-1] is not '':
            str1 = incrementString(str1[:-1])
        else:
            str1 = 'a'
            str1 = str1 + ''.join(arr[0])
    else:
        arr[0] = chr(ord(arr[0]) + 1)
        str1 = str1[:-1] + ''.join(arr[0])

    return str1


while True:
    val = incrementString(val)
    print(val)


<hr style="border-top: 1px;" />

<a name="nth-max" href="#nth-max" >Find Nth Max or Largest element of unsorted array </a>

	arr = [7,2,1,3,10,4,5,8,9,6]
	nthMax = 2 #specify max element here
	maxArr = arr

	for i in range (0, len(maxArr)):
	    for j in range (i, len(maxArr)):
		if (maxArr[i] < maxArr[j]):
		    maxArr[i],maxArr[j] = maxArr[j],maxArr[i]
		    if i == nthMax:
			break

	print(maxArr)
	print(maxArr[nthMax-1])


-- java solution with Heap

package com.company;

import java.util.PriorityQueue;



class JavaTest {

    public static int findKthLargest(int[] nums, int k) {
        PriorityQueue q = new PriorityQueue(k);
        for(int i: nums){

            q.offer(i);

            if(q.size()>k){
                q.poll();
            }

        }

        return (int)q.peek();
    }

    public static void main (String[] args) throws java.lang.Exception
    {

        int[] arr = new int[]{7, 2, 1, 3, 10, 4, 5, 8, 9, 6};
        int k = 2;

        System.out.println(findKthLargest(arr, k));

    }
}


<hr style="border-top: 1px;" />


<a name="remove-all-adjacent-duplicates" href="#remove-all-adjacent-duplicates" > Recursively remove all adjacent duplicates </a>

problem url <a href="http://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/">http://www.geeksforgeeks.org/recursively-remove-adjacent-duplicates-given-string/</a>


Input:  azxxzy
Output: ay
First "azxxzy" is reduced to "azzy".
The string "azzy" contains duplicates,
so it is further reduced to "ay".

Input: geeksforgeeg
Output: gksfor
First "geeksforgeeg" is reduced to
"gksforgg". The string "gksforgg"
contains duplicates, so it is further
reduced to "gksfor".

Input: caaabbbaacdddd
Output: Empty String

Input: acaaabbbacdddd
Output: acac



def removeAdjoints(ipx, start, end):
    if(len(ipx) == 0):
        print("blank")
    else:
        print(ipx)

    if len(ipx) > 0 and end < len(ipx):
        if ipx[start] == ipx[end]:
            if end + 1 < len(ipx):
                removeAdjoints(ipx, start, end + 1)
            elif start < end:
                ipx = ipx[0:start]
                if len(ipx) > 0:
                    removeAdjoints(ipx, 0, 1)
        elif start + 1 < end:
            ipx = ipx[0:start] + ipx[end:len(ipx)]
            removeAdjoints(ipx, 0, 1)
        else:
            if end + 1 < len(ipx):
                removeAdjoints(ipx, start + 1, end + 1)


removeAdjoints("azxxzy", 0, 1)
print("----")
removeAdjoints("geeksforgeeg", 0, 1)
print("----")
removeAdjoints("gksforgg", 0, 1)
print("----")
removeAdjoints("caaabbbaacdddd", 0, 1)
print("----")
removeAdjoints("dddd", 0, 1)
print("----")



<hr style="border-top: 1px;" />


<a name="level-order-tree-traversal" href="#level-order-tree-traversal" >Level Order Tree Traversal or breadth first traversal for the tree.</a>


''

input tree

                                1
                2                               3
        4                 5             6               7
      8  9              10 11        12  13          14   15

'''


class Node:
    pass


root = Node()
root.data = 1
root.left = Node()
root.right = Node()

root.left.data = 2
root.left.left = Node()
root.left.right = Node()

root.right.data = 3
root.right.left = Node()
root.right.right = Node()

node2 = root.left
node2.left.data = 4
node2.right.data = 5

node3 = root.right
node3.left.data = 6
node3.right.data = 7

node4 = node2.left
node4.left = Node()
node4.left.data = 8
node4.right = Node()
node4.right.data = 9


node5 = node2.right
node5.left = Node()
node5.left.data = 10
node5.right = Node()
node5.right.data = 11

node6 = node3.left
node6.left = Node()
node6.left.data = 10

# node7 = node3.right
# node7.right = Node()
# node7.right.data = 11


queue = []

def printTree(rootNode, queue):

    if rootNode.data is not None:
        print(rootNode.data)

    t = None
    while len(queue) > 0:
        t = queue[len(queue)-1]
        queue.pop()
        print(t.data)
    if t is not None and hasattr(t, "right"):
        queue.append(t.right)
    if t is not None and hasattr(t, "left"):
        queue.append(t.left)

    if hasattr(rootNode, "right"):
        queue.append(rootNode.right)
    if rootNode is not None and hasattr(rootNode, "left"):
        printTree(rootNode.left, queue)



printTree(root, queue)

# print(root.data)

more about problem at http://www.geeksforgeeks.org/level-order-tree-traversal/

<hr style="border-top: 1px;" />


<a name="height-of-tree" href="#height-of-tree" >Find height of tree</a>



'''

input tree

                                1
                2                               3
        4                 5             6               7
      8  9              10 11        12  13          14   15

'''


class Node:
    pass


root = Node()
root.data = 1
root.left = Node()
root.right = Node()

root.left.data = 2
root.left.left = Node()
root.left.right = Node()

root.right.data = 3
root.right.left = Node()
root.right.right = Node()

node2 = root.left
node2.left.data = 4
node2.right.data = 5

node3 = root.right
node3.left.data = 6
node3.right.data = 7

node4 = node2.left
node4.left = Node()
node4.left.data = 8
node4.right = Node()
node4.right.data = 9


node5 = node2.right
node5.left = Node()
node5.left.data = 10
node5.right = Node()
node5.right.data = 11

node6 = node3.left
node6.left = Node()
node6.left.data = 10

node10 = node5.left
node10.left = Node()
node10.left.data = 16


# node7 = node3.right
# node7.right = Node()
# node7.right.data = 11


maxLength = 0

def findHightOfTree(head, length):
    if head is None:
        print(length)
        return length
    maxHeight = 0
    if hasattr(head, "left"):
        lhight = findHightOfTree(head.left, length)
        maxHeight = lhight + 1
    if hasattr(head, "right"):
        rhight = findHightOfTree(head.right, length)
        if maxHeight - 1 < rhight:
            maxHeight = rhight+1

    print(maxHeight)
    return maxHeight;

print(findHightOfTree(root, 0))



<hr style="border-top: 1px;" />


<a name="producer-consumer-problem" href="#producer-consumer-problem" >Producer Consumer Problem</a>


// Java program to implement solution of producer
// consumer problem.
import java.util.LinkedList;

public class Threadexample
{
    public static void main(String[] args)
                        throws InterruptedException
    {
        // Object of a class that has both produce()
        // and consume() methods
        final PC pc = new PC();

        // Create producer thread
        Thread t1 = new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    pc.produce();
                }
                catch(InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        });

        // Create consumer thread
        Thread t2 = new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                try
                {
                    pc.consume();
                }
                catch(InterruptedException e)
                {
                    e.printStackTrace();
                }
            }
        });

        // Start both threads
        t1.start();
        t2.start();

        // t1 finishes before t2
        t1.join();
        t2.join();
    }

    // This class has a list, producer (adds items to list
    // and consumber (removes items).
    public static class PC
    {
        // Create a list shared by producer and consumer
        // Size of list is 2.
        LinkedList<Integer> list = new LinkedList<>();
        int capacity = 2;

        // Function called by producer thread
        public void produce() throws InterruptedException
        {
            int value = 0;
            while (true)
            {
                synchronized (this)
                {
                    // producer thread waits while list
                    // is full
                    while (list.size()==capacity)
                        wait();

                    System.out.println("Producer produced-"
                                                  + value);

                    // to insert the jobs in the list
                    list.add(value++);

                    // notifies the consumer thread that
                    // now it can start consuming
                    notify();

                    // makes the working of program easier
                    // to  understand
                    Thread.sleep(1000);
                }
            }
        }

        // Function called by consumer thread
        public void consume() throws InterruptedException
        {
            while (true)
            {
                synchronized (this)
                {
                    // consumer thread waits while list
                    // is empty
                    while (list.size()==0)
                        wait();

                    //to retrive the ifrst job in the list
                    int val = list.removeFirst();

                    System.out.println("Consumer consumed-"
                                                    + val);

                    // Wake up producer thread
                    notify();

                    // and sleep
                    Thread.sleep(1000);
                }
            }
        }
    }
}


more at http://www.geeksforgeeks.org/producer-consumer-solution-using-threads-java/


Approach 2

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

/**
 * Simple Java program to demonstrate How to use wait, notify and notifyAll()
 * method in Java by solving producer consumer problem.
 *
 * @author Javin Paul
 */
public class ProducerConsumerInJava {

    public static void main(String args[]) {
        System.out.println("How to use wait and notify method in Java");
        System.out.println("Solving Producer Consumper Problem");

        Queue<Integer> buffer = new LinkedList<>();
        int maxSize = 10;

        Thread producer = new Producer(buffer, maxSize, "PRODUCER");
        Thread consumer = new Consumer(buffer, maxSize, "CONSUMER");

        producer.start();
        consumer.start();


    }

}

/**
 * Producer Thread will keep producing values for Consumer
 * to consumer. It will use wait() method when Queue is full
 * and use notify() method to send notification to Consumer
 * Thread.
 *
 *
 */
class Producer extends Thread {
    private Queue<Integer> queue;
    private int maxSize;

    public Producer(Queue<Integer> queue, int maxSize, String name){
        super(name);
        this.queue = queue;
        this.maxSize = maxSize;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (queue) {
                while (queue.size() == maxSize) {
                    try {
                        System.out .println("Queue is full, "
                                + "Producer thread waiting for "
                                + "consumer to take something from queue");
                        queue.wait();
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }

                Random random = new Random();
                int i = random.nextInt();
                System.out.println("Producing value : " + i);
                queue.add(i);
                queue.notifyAll();
            }

        }
    }
}

/**
 * Consumer Thread will consumer values form shared queue.
 * It will also use wait() method to wait if queue is
 * empty. It will also use notify method to send
 * notification to producer thread after consuming values
 * from queue.
 *
 *
 */
class Consumer extends Thread {
    private Queue<Integer> queue;
    private int maxSize;

    public Consumer(Queue<Integer> queue, int maxSize, String name){
        super(name);
        this.queue = queue;
        this.maxSize = maxSize;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (queue) {
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty,"
                            + "Consumer thread is waiting"
                            + " for producer thread to put something in queue");
                    try {
                        queue.wait();
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }

                }
                System.out.println("Consuming value : " + queue.remove());
                queue.notifyAll();
            }

        }
    }
}

Output
How to use wait and notify method in Java
Solving Producer Consumper Problem
Queue is empty,Consumer thread is waiting for producer thread to put something in queue
Producing value : -1692411980
Producing value : 285310787
Producing value : -1045894970
Producing value : 2140997307
Producing value : 1379699468
Producing value : 912077154
Producing value : -1635438928
Producing value : -500696499
Producing value : -1985700664
Producing value : 961945684
Queue is full, Producer thread waiting for consumer to take something from queue
Consuming value : -1692411980
Consuming value : 285310787
Consuming value : -1045894970
Consuming value : 2140997307
Consuming value : 1379699468
Consuming value : 912077154
Consuming value : -1635438928
Consuming value : -500696499
Consuming value : -1985700664
Consuming value : 961945684
Queue is empty,Consumer thread is waiting for producer thread to put something in queue
Producing value : 1182138498


more details at http://javarevisited.blogspot.in/2015/07/how-to-use-wait-notify-and-notifyall-in.html#axzz4hJulc43E

http://javarevisited.blogspot.in/2011/05/wait-notify-and-notifyall-in-java.html#axzz4hJulc43E

<hr style="border-top: 1px;" />


<a name="print-binary-tree-in-vertical-order" href="#print-binary-tree-in-vertical-order" >Print a Binary Tree in Vertical Order</a>

<img src="data:image/png;base64,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" ></img>



# method have used hashmap

class Node:
    pass


root = Node()
root.data = 1
root.left = Node()
root.right = Node()

root.left.data = 2
root.left.left = Node()
root.left.right = Node()

root.right.data = 3
root.right.left = Node()
root.right.right = Node()

node2 = root.left
node2.left.data = 4
node2.right.data = 5

node3 = root.right
node3.left.data = 6
node3.right.data = 7

node6 = node3.left
node6.right = Node()
node6.right.data = 8


node7 = node3.right
node7.right = Node()
node7.right.data = 9




def getVerticalOrder(node, hd, m):

    if node is None:
        return
    else:
        try:
            m[hd].append(node.data)
        except:
            m[hd] = [node.data]

    if hasattr(node, "right"):
        getVerticalOrder(node.right, hd+1, m)
    if hasattr(node, "left"):
        getVerticalOrder(node.left, hd-1, m)

dictM = dict()
getVerticalOrder(root, 0 , dictM)


print(sorted(dictM))

for index, value in enumerate(sorted(dictM)):
    for data in dictM[value]:
        print(data, end="")
    print()


more details at http://www.geeksforgeeks.org/print-binary-tree-vertical-order/

http://www.geeksforgeeks.org/print-binary-tree-vertical-order-set-2/

<hr style="border-top: 1px;" />

<a name="how-hashmap-works" href="#how-hashmap-works" >How HashMap / HashTable works</a>

<iframe width="560" height="315" src="https://www.youtube.com/embed/shs0KM3wKv8" frameborder="0" allowfullscreen></iframe>

<hr style="border-top: 1px;" />

<a name="heaps" href="#heaps" >Data Structures: Heaps</a>

<iframe width="560" height="315" src="https://www.youtube.com/embed/t0Cq6tVNRBA" frameborder="0" allowfullscreen></iframe>

<hr style="border-top: 1px;" />

<a name="trees" href="#trees" >Data Structures: Trees</a>

<iframe width="560" height="315" src="https://www.youtube.com/embed/oSWTXtMglKE" frameborder="0" allowfullscreen></iframe>

<hr style="border-top: 1px;" />

<a name="tries" href="#tries" >Data Structures: Tries </a>

<iframe width="560" height="315" src="https://www.youtube.com/embed/zIjfhVPRZCg" frameborder="0" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/vlYZb68kAY0" frameborder="0" allowfullscreen></iframe>

<hr style="border-top: 1px;" />

<a name="find-cost-of-object-nested-approch" href="#find-cost-of-object-nested-approch" >Find The Cost (Nested Approch)</a>

Let's say the building has 'n' floors, each fllor has meeting rooms & work-stations, each room has several objects (table, chairs, tv..).
Find the cost of perticular room, complete floor or a building.

Meeting Room 1:

Item
Cost

TV
90000

Chairs
150000

Table
200000

Total:
440000



Floor 1:

Meeting Room1          440000

Meeting Room2          650000

Total: 1090000


class Object:
    name = None
    value = None
    containsObject = None
    pass

def getCostOfMultipleObjects(manyObjectOfBuilding):
    totalCost = 0
    for obj in manyObjectOfBuilding:
        totalCost += getCost(obj)
    return totalCost

def getCost(anyObjectOfBuilding):
    if anyObjectOfBuilding.containsObject is not None and len(anyObjectOfBuilding.containsObject) > 0:
        return anyObjectOfBuilding.value + getCostOfMultipleObjects(anyObjectOfBuilding.containsObject)
    else:
        return anyObjectOfBuilding.value

table1 = Object()
table1.name = 'table_1'
table1.value = 5

lamp1 = Object()
lamp1.name = 'lamp_1'
lamp1.value = 1

tv1 = Object()
tv1.name = 'tv_1'
tv1.value = 3

meetingRoom1 = Object()
meetingRoom1.name = 'meetingRoom_1'
meetingRoom1.value = 10
meetingRoom1.containsObject = [lamp1, table1]

meetingRoom2 = Object()
meetingRoom2.name = 'meetingRoom_2'
meetingRoom2.value = 20
meetingRoom2.containsObject = [lamp1, table1, tv1]

floor1 = Object()
floor1.name = 'floor_1'
floor1.value = 20
floor1.containsObject = [meetingRoom1, meetingRoom2]

builing1 = Object()
builing1.name = 'building_1'
builing1.value = 100
builing1.containsObject = [floor1]

print('t1', getCost(table1))
print('m1', getCost(meetingRoom1))
print('m2', getCost(meetingRoom2))
print('f1', getCost(floor1))
print('b1', getCost(builing1))


<hr style="border-top: 1px;" />

A program to check if a binary tree is BST or not

http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/

<hr style="border-top: 1px;" />

Tree Traversals (Inorder, Preorder and Postorder)

http://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/

<hr style="border-top: 1px;" />

Search in a row wise and column wise sorted matrix

www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/

<hr style="border-top: 1px;" />

<a name="lru-cache" href="#lru-cache" >LRU Cache (Java)</a>

Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Analysis

The key to solve this problem is using a double linked list which enables us to quickly move nodes.

<img  width="650" height="296"  src="data:image/png;base64,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">

The LRU cache is a hash table of keys and double linked nodes. The hash table makes the time of get() to be O(1). The list of double linked nodes make the nodes adding/removal operations O(1).

Java Solution

Define a double linked list node.

class Node{
    int key;
    int value;
    Node pre;
    Node next;

    public Node(int key, int value){
        this.key = key;
        this.value = value;
    }
}

public class LRUCache {
    int capacity;
    HashMap<Integer, Node> map = new HashMap<Integer, Node>();
    Node head=null;
    Node end=null;

    public LRUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if(map.containsKey(key)){
            Node n = map.get(key);
            remove(n);
            setHead(n);
            return n.value;
        }

        return -1;
    }

    public void remove(Node n){
        if(n.pre!=null){
            n.pre.next = n.next;
        }else{
            head = n.next;
        }

        if(n.next!=null){
            n.next.pre = n.pre;
        }else{
            end = n.pre;
        }

    }

    public void setHead(Node n){
        n.next = head;
        n.pre = null;

        if(head!=null)
            head.pre = n;

        head = n;

        if(end ==null)
            end = head;
    }

    public void set(int key, int value) {
        if(map.containsKey(key)){
            Node old = map.get(key);
            old.value = value;
            remove(old);
            setHead(old);
        }else{
            Node created = new Node(key, value);
            if(map.size()>=capacity){
                map.remove(end.key);
                remove(end);
                setHead(created);

            }else{
                setHead(created);
            }

            map.put(key, created);
        }
    }
}

-- linked hash map implementation

import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCacheImpl extends LinkedHashMap<Integer, String> {
   private static final long serialVersionUID = 1L;
   private int capacity;

   public LRUCacheImpl(int capacity, float loadFactor){
      super(capacity, loadFactor, true);
      this.capacity = capacity;
   }

   /**
    * removeEldestEntry() should be overridden by the user, otherwise it will not
    * remove the oldest object from the Map.
    */
   @Override
   protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest){
      return size() > this.capacity;
   }

   public static void main(String arg[]){
      LRUCacheImpl lruCache = new LRUCacheImpl(4, 0.75f);

      lruCache.put(1, "Object1");
      lruCache.put(2, "Object2");
      lruCache.put(3, "Object3");
      lruCache.get(1);
      lruCache.put(4, "Object4");
      System.out.println(lruCache);
      lruCache.put(5, "Object5");
      lruCache.get(3);
      lruCache.put(6, "Object6");
      System.out.println(lruCache);
      lruCache.get(4);
      lruCache.put(7, "Object7");
      lruCache.put(8, "Object8");
      System.out.println(lruCache);
   }
}

-- output

{2=Object2, 3=Object3, 1=Object1, 4=Object4}
{4=Object4, 5=Object5, 3=Object3, 6=Object6}
{6=Object6, 4=Object4, 7=Object7, 8=Object8}

<hr style="border-top: 1px;" />


<a name="RemoveNthNodeFromEndOfList" href="#RemoveNthNodeFromEndOfList" >Remove Nth Node From End of List (Java)</a>

Given a linked list, remove the nth node from the end of list and return its head.

For example, given linked list 1->2->3->4->5 and n = 2, the result is 1->2->3->5.

Java Solution 1 - Naive Two Passes

Calculate the length first, and then remove the nth from the beginning.

public ListNode removeNthFromEnd(ListNode head, int n) {
    if(head == null)
        return null;

    //get length of list
    ListNode p = head;
    int len = 0;
    while(p != null){
        len++;
        p = p.next;
    }

    //if remove first node
    int fromStart = len-n+1;
    if(fromStart==1)
        return head.next;

    //remove non-first node
    p = head;
    int i=0;
    while(p!=null){
        i++;
        if(i==fromStart-1){
            p.next = p.next.next;
        }
        p=p.next;
    }

    return head;
}


Java Solution 2 - One Pass

Use fast and slow pointers. The fast pointer is n steps ahead of the slow pointer. When the fast reaches the end, the slow pointer points at the previous element of the target element.

public ListNode removeNthFromEnd(ListNode head, int n) {
    if(head == null)
        return null;

    ListNode fast = head;
    ListNode slow = head;

    for(int i=0; i<n; i++){
        fast = fast.next;
    }

    //if remove the first node
    if(fast == null){
        head = head.next;
        return head;
    }

    while(fast.next != null){
        fast = fast.next;
        slow = slow.next;
    }

    slow.next = slow.next.next;

    return head;
}

<hr style="border-top: 1px;" />


<a name="linked-list-cycle" href="#linked-list-cycle" >Linked List Cycle Detect</a>

Given a linked list, determine if it has a cycle in it.

Analysis

If we have 2 pointers - fast and slow. It is guaranteed that the fast one will meet the slow one if there exists a circle.

The problem can be demonstrated in the following diagram:

<img  width="300" height="211"  src="data:image/png;base64,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">

Java Solution

public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow == fast)
                return true;
        }

        return false;
    }
}


<hr style="border-top: 1px;" />

<a name="money-transfer-operation-program" href="#money-transfer-operation-program" >Money Transfer Operation Program</a>

Write java program to perform a money transfer operation  for a bank, which is multi-threaded and can run parallel with multi-processor machines

Solution can be developed with cachedthreadpool and executorservices.

FixedThreadPool vs CachedThreadPool: the lesser of two evils



A CachedThreadPool is exactly what you should use for your situation as there are no negative consequence to using one for long running threads. The comment in the java doc about CachedThreadPools being suitable for short tasks merely suggest that they are particularly appropriate for such cases, not that they cannot or should not be used for tasks involving long running tasks.

To elaborate further, Executors.newCachedThreadPool and Executors.newFixedThreadPool are both backed by the same thread pool implementation (at least in the open JDK) just with different parameters. The differences just being their thread minimum, maximum, thread kill time, and queue type.

public static ExecutorService newFixedThreadPool(int nThreads) {
     return new ThreadPoolExecutor(nThreads, nThreads,
                                   0L, TimeUnit.MILLISECONDS,
                                   new LinkedBlockingQueue<Runnable>());
 }

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                 60L, TimeUnit.SECONDS,
                                 new SynchronousQueue<Runnable>());
}

A FixedThreadPool does have its advantages when you do in fact want to work with a fixed number of threads, since then you can submit any number of tasks to the executor service while knowing that the number of threads will be maintained at the level you specified. If you explicitly want to grow the number of threads, then this is not the appropriate choice.

This does however mean that the one issue that you may have with the CachedThreadPool is in regards to limiting the number of threads that are running concurrently. The CachedThreadPool will not limit them for you, so you may need to write your own code to ensure that you do not run too many threads. This really depends on the design of your application and how tasks are submitted to the executor service.


<hr style="border-top: 1px;" />


<a name="subset-sum-problems" href="#subset-sum-problems" >Subset Sum Problem</a>

Given a set of non-negative integers, and a value sum, determine if there is a subset of the given set with sum equal to given sum.

Examples: set[] = {3, 34, 4, 12, 5, 2}, sum = 9
Output:  True  //There is a subset (4, 5) with sum 9.


# A recursive solution for subset sum
# problem

# Returns true if there is a subset
# of set[] with sun equal to given sum
def isSubsetSum(set,n, sum) :

    # Base Cases
    if (sum == 0) :
        return True
    if (n == 0 and sum != 0) :
        return False

    # If last element is greater than
    # sum, then ignore it
    if (set[n - 1] > sum) :
        return isSubsetSum(set, n - 1, sum);

    # else, check if sum can be obtained
    # by any of the following
    # (a) including the last element
    # (b) excluding the last element
    return isSubsetSum(set, n-1, sum) or isSubsetSum(set, n-1, sum-set[n-1])


# Driver program to test above function
set = [3, 34, 4, 12, 5, 2]
sum = 9
n = len(set)
if (isSubsetSum(set, n, sum) == True) :
    print("Found a subset with given sum")
else :
    print("No subset with given sum")


-----

similar another problem

Given an array, find there are 3 numbers have when we add them the value will equals a specified sum Example: {1,4,6,10,20,21} Sum=32, Result:true (1+10+21) Sum=65, Result:false

'''
solution pending
'''

arr = [1,4,6,10,20,21]
sum = 32

isSumMatching(arr, sum, 0,0,0)

more at <a href="https://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/">https://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/</a>

added on 11-Feb-2018

<hr style="border-top: 1px;" />


<a name="api-to-handel-navigation-of-web-browser" href="#api-to-handel-navigation-of-web-browser" >API to handel navigation of web browser</a>

Design an API to handle the navigation history of a web browser (previous page, next page, list the 10 previous pages), and that can be reusable in many parts of the application (here I give concrete examples in our app). Then, sketch up an implementation.

I like this one, because it's simple enough, it's easy to illustrate, it can be solved step by step (add additional behaviors without breaking everything), it allows to talk about edge cases and error handling, and it also allows to talk about data structures.

provide Concrete example

(For a java desktop developper)

-- solution pending

added on 18-Feb-2018

<hr style="border-top: 1px;" />


<a name="external-sorting" href="#external-sorting" >Sort a file with huge volume of data given memory constraint</a>

Points:

    We process thousands of flat files in a day, concurrently.
    Memory constraint is a major issue.
    We use thread for each file process.
    We don't sort by columns. Each line (record) in the file is treated as one column.

Can't Do:

    We cannot use unix/linux's sort commands.
    We cannot use any database system no matter how light they can be.

Now, we cannot just load everything in a collection and use the sort mechanism. It will eat up all the memory and the program is gonna get a heap error.

In that situation, how would you sort the records/lines in a file?


One example of external sorting is the external merge sort algorithm, which is a K-way merge algorithm. It sorts chunks that each fit in RAM, then merges the sorted chunks together.[1][2]

The algorithm first sorts M items at a time and puts the sorted lists back into external memory. It then recursively does a M B {\displaystyle {\tfrac {M}{B}}} {\displaystyle {\tfrac {M}{B}}}-way merge on those sorted lists. To do this merge, B elements from each sorted list are loaded into internal memory, and the minimum is repeatedly outputted.

For example, for sorting 900 megabytes of data using only 100 megabytes of RAM:

1. Read 100 MB of the data in main memory and sort by some conventional method, like quicksort.

2. Write the sorted data to disk.

3. Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.

4. Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)

5. Perform a 9-way merge and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally -- because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed.

Historically, instead of a sort, sometimes a replacement-selection algorithm was used to perform the initial distribution, to produce on average half as many output chunks of double the length.


2-way merge

A 2-way merge, or a binary merge, has been studied extensively due to its key role in merge sort. An example of such is the classic merge that appears frequently in merge sort examples. The classic merge outputs the data item with the lowest key at each step; given some sorted lists, it produces a sorted list containing all the elements in any of the input lists, and it does so in time proportional to the sum of the lengths of the input lists.


k-way merge

The k-way merge problem consists of merging k sorted arrays to produce a single sorted array with the same elements. Denote by n the total number of elements. n is equal to the size of the output array and the sum of the sizes of the k input arrays. For simplicity, we assume that none of the input arrays is empty. As a consequence k < n, which simplifies the reported running times. The problem can be solved in O(n log k) running time with O(n) space. Several algorithms that achieve this running time exist.

added on 20-Feb-2018

<hr style="border-top: 1px;" />




</pre>



</div>

</body>

</html>
